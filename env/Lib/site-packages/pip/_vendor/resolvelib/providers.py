class AbstractProvider(object):
    """Delegate class to provide requirement interface for the resolver."""

    def identify(self, requirement_or_candidate):
        """Given a requirement, return an identifier for it.

        This is used to identify a requirement, e.g. whether two requirements
        should have their specifier parts merged.
        """
        raise NotImplementedError

    def get_preference(self, identifier, resolutions, candidates, information):
        """Produce a sort key for given requirement based on preference.

        The preference is defined as "I think this requirement should be
        resolved first". The lower the return value is, the more preferred
        this group of arguments is.

        :param identifier: An identifier as returned by ``identify()``. This
            identifies the dependency matches of which should be returned.
        :param resolutions: Mapping of candidates currently pinned by the
            resolver. Each key is an identifier, and the value a candidate.
            The candidate may conflict with requirements from ``information``.
        :param candidates: Mapping of each dependency's possible candidates.
            Each value is an iterator of candidates.
        :param information: Mapping of requirement information of each package.
            Each value is an iterator of *requirement information*.

        A *requirement information* instance is a named tuple with two members:

<<<<<<< HEAD
        * ``requirement`` specifies a requirement contributing to the current
          list of candidates.
        * ``parent`` specifies the candidate that provides (dependend on) the
          requirement, or ``None`` to indicate a root requirement.
=======
        * `requirement` specifies a requirement contributing to the current
          candidate list
        * `parent` specifies the candidate that provids (dependend on) the
          requirement, or `None` to indicate a root requirement.
>>>>>>> ad0cefc4b9add9b78a9fdabd954915450107fc37

        The preference could depend on a various of issues, including (not
        necessarily in this order):

        * Is this package pinned in the current resolution result?
        * How relaxed is the requirement? Stricter ones should probably be
          worked on first? (I don't know, actually.)
        * How many possibilities are there to satisfy this requirement? Those
          with few left should likely be worked on first, I guess?
        * Are there any known conflicts for this requirement? We should
          probably work on those with the most known conflicts.

        A sortable value should be returned (this will be used as the ``key``
        parameter of the built-in sorting function). The smaller the value is,
        the more preferred this requirement is (i.e. the sorting function
        is called with ``reverse=False``).
        """
        raise NotImplementedError

<<<<<<< HEAD
    def find_matches(self, identifier, requirements, incompatibilities):
        """Find all possible candidates that satisfy given constraints.

        :param identifier: An identifier as returned by ``identify()``. This
            identifies the dependency matches of which should be returned.
        :param requirements: A mapping of requirements that all returned
            candidates must satisfy. Each key is an identifier, and the value
            an iterator of requirements for that dependency.
        :param incompatibilities: A mapping of known incompatibilities of
            each dependency. Each key is an identifier, and the value an
            iterator of incompatibilities known to the resolver. All
            incompatibilities *must* be excluded from the return value.
=======
    def find_matches(self, requirement):
        """Find all possible candidates that satisfy a requirement.
>>>>>>> ad0cefc4b9add9b78a9fdabd954915450107fc37

        This should try to get candidates based on the requirement's type.
        For VCS, local, and archive requirements, the one-and-only match is
        returned, and for a "named" requirement, the index(es) should be
        consulted to find concrete candidates for this requirement.

<<<<<<< HEAD
        The return value should produce candidates ordered by preference; the
        most preferred candidate should come first. The return type may be one
        of the following:

        * A callable that returns an iterator that yields candidates.
        * An collection of candidates.
        * An iterable of candidates. This will be consumed immediately into a
          list of candidates.
=======
        The returned candidates should be sorted by reversed preference, e.g.
        the most preferred should be LAST. This is done so list-popping can be
        as efficient as possible.
>>>>>>> ad0cefc4b9add9b78a9fdabd954915450107fc37
        """
        raise NotImplementedError

    def is_satisfied_by(self, requirement, candidate):
        """Whether the given requirement can be satisfied by a candidate.

<<<<<<< HEAD
        The candidate is guarenteed to have been generated from the
        requirement.

        A boolean should be returned to indicate whether ``candidate`` is a
=======
        A boolean should be returned to indicate whether `candidate` is a
>>>>>>> ad0cefc4b9add9b78a9fdabd954915450107fc37
        viable solution to the requirement.
        """
        raise NotImplementedError

    def get_dependencies(self, candidate):
        """Get dependencies of a candidate.

        This should return a collection of requirements that `candidate`
        specifies as its dependencies.
        """
        raise NotImplementedError


class AbstractResolver(object):
    """The thing that performs the actual resolution work."""

    base_exception = Exception

    def __init__(self, provider, reporter):
        self.provider = provider
        self.reporter = reporter

    def resolve(self, requirements, **kwargs):
        """Take a collection of constraints, spit out the resolution result.

        Parameters
        ----------
        requirements : Collection
            A collection of constraints
        kwargs : optional
            Additional keyword arguments that subclasses may accept.

        Raises
        ------
        self.base_exception
            Any raised exception is guaranteed to be a subclass of
            self.base_exception. The string representation of an exception
            should be human readable and provide context for why it occurred.

        Returns
        -------
        retval : object
            A representation of the final resolution state. It can be any object
            with a `mapping` attribute that is a Mapping. Other attributes can
            be used to provide resolver-specific information.

            The `mapping` attribute MUST be key-value pair is an identifier of a
            requirement (as returned by the provider's `identify` method) mapped
            to the resolved candidate (chosen from the return value of the
            provider's `find_matches` method).
        """
        raise NotImplementedError
